#!/usr/bin/env python3
"""
Script para listar todos os objetos Oracle acess√≠veis pelo usu√°rio GEODATA
Utiliza as credenciais do arquivo .env do projeto ETL GEODATA
"""

import os
import cx_Oracle
import pandas as pd
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any
from sqlalchemy import create_engine, text

# Carregar vari√°veis de ambiente do arquivo .env
try:
    from dotenv import load_dotenv
    # Procurar arquivo .env no diret√≥rio do projeto
    env_path = Path(__file__).parent / '.env'
    if env_path.exists():
        load_dotenv(env_path)
        print(f"‚úÖ Configura√ß√µes carregadas de: {env_path}")
    else:
        print("‚ö†Ô∏è  Arquivo .env n√£o encontrado no diret√≥rio do projeto")
        print("‚ö†Ô∏è  Tentando usar vari√°veis de ambiente do sistema...")
except ImportError:
    print("‚ö†Ô∏è  python-dotenv n√£o instalado, usando vari√°veis de ambiente do sistema")

def get_oracle_engine():
    """Cria engine SQLAlchemy para Oracle usando credenciais do .env"""
    try:
        oracle_host = os.getenv('ORACLE_HOST')
        oracle_port = int(os.getenv('ORACLE_PORT', '1521'))
        oracle_service = os.getenv('ORACLE_SERVICE_NAME', 'ORCL')
        oracle_user = os.getenv('ORACLE_USER')
        oracle_password = os.getenv('ORACLE_PASSWORD')
        
        # Validar credenciais obrigat√≥rias
        if not all([oracle_host, oracle_user, oracle_password]):
            missing = []
            if not oracle_host: missing.append('ORACLE_HOST')
            if not oracle_user: missing.append('ORACLE_USER')
            if not oracle_password: missing.append('ORACLE_PASSWORD')
            raise ValueError(f"Vari√°veis de ambiente obrigat√≥rias n√£o definidas: {missing}")
        
        print(f"üì° Conectando em Oracle: {oracle_host}:{oracle_port}/{oracle_service}")
        print(f"üë§ Usu√°rio: {oracle_user}")
        
        # Criar string de conex√£o SQLAlchemy
        dsn = cx_Oracle.makedsn(oracle_host, oracle_port, service_name=oracle_service)
        connection_string = f"oracle+cx_oracle://{oracle_user}:{oracle_password}@{dsn}"
        
        # Criar engine
        engine = create_engine(
            connection_string,
            echo=False,
            pool_pre_ping=True,
            pool_recycle=3600
        )
        
        # Testar conex√£o
        with engine.connect() as conn:
            conn.execute(text("SELECT 1 FROM DUAL"))
        
        print("‚úÖ Conex√£o Oracle estabelecida com sucesso!")
        return engine
        
    except Exception as e:
        print(f"‚ùå Erro ao conectar no Oracle: {e}")
        return None

def execute_query_to_dataframe(engine, query: str, description: str) -> pd.DataFrame:
    """Executa query e retorna DataFrame"""
    try:
        print(f"üîç Executando consulta: {description}")
        df = pd.read_sql(query, engine)
        print(f"   üìä {len(df)} registros encontrados")
        
        # Debug: mostrar colunas retornadas
        if not df.empty:
            print(f"   üîç Colunas retornadas: {list(df.columns)}")
            if len(df) > 0:
                print(f"   üîç Primeira linha: {dict(df.iloc[0])}")
        else:
            print(f"   ‚ö†Ô∏è  DataFrame vazio retornado")
            
        return df
    except Exception as e:
        print(f"   ‚ùå Erro na consulta {description}: {e}")
        return pd.DataFrame()

def get_bentivi_objects(engine) -> Dict[str, pd.DataFrame]:
    """Obt√©m objetos do schema BENTIVI que o usu√°rio GEODATA pode acessar"""
    queries = {
        'tables': {
            'query': """
                SELECT 
                    TABLE_NAME,
                    'TABLE' as OBJECT_TYPE,
                    NUM_ROWS,
                    LAST_ANALYZED,
                    TABLESPACE_NAME
                FROM ALL_TABLES 
                WHERE OWNER = 'BENTIVI'
                ORDER BY TABLE_NAME
            """,
            'description': 'Tabelas do schema BENTIVI'
        },
        'views': {
            'query': """
                SELECT 
                    VIEW_NAME as TABLE_NAME,
                    'VIEW' as OBJECT_TYPE,
                    TEXT_LENGTH,
                    READ_ONLY
                FROM ALL_VIEWS 
                WHERE OWNER = 'BENTIVI'
                ORDER BY VIEW_NAME
            """,
            'description': 'Views do schema BENTIVI'
        },
        'procedures': {
            'query': """
                SELECT 
                    OBJECT_NAME as TABLE_NAME,
                    OBJECT_TYPE,
                    STATUS,
                    CREATED,
                    LAST_DDL_TIME
                FROM ALL_OBJECTS 
                WHERE OWNER = 'BENTIVI' 
                AND OBJECT_TYPE IN ('PROCEDURE', 'PACKAGE', 'PACKAGE BODY')
                ORDER BY OBJECT_TYPE, OBJECT_NAME
            """,
            'description': 'Procedures e Packages do schema BENTIVI'
        },
        'functions': {
            'query': """
                SELECT 
                    OBJECT_NAME as TABLE_NAME,
                    OBJECT_TYPE,
                    STATUS,
                    CREATED,
                    LAST_DDL_TIME
                FROM ALL_OBJECTS 
                WHERE OWNER = 'BENTIVI' 
                AND OBJECT_TYPE = 'FUNCTION'
                ORDER BY OBJECT_NAME
            """,
            'description': 'Functions do schema BENTIVI'
        }
    }
    
    print("\n" + "="*60)
    print("üìã OBJETOS DO SCHEMA BENTIVI ACESS√çVEIS PELO USU√ÅRIO GEODATA")
    print("="*60)
    
    results = {}
    for category, info in queries.items():
        df = execute_query_to_dataframe(engine, info['query'], info['description'])
        results[category] = df
    
    return results

def get_bentivi_privileges(engine) -> Dict[str, pd.DataFrame]:
    """Obt√©m privil√©gios espec√≠ficos do usu√°rio GEODATA no schema BENTIVI"""
    queries = {
        'table_privileges': {
            'query': """
                SELECT 
                    TABLE_NAME,
                    'PRIVILEGE' as OBJECT_TYPE,
                    PRIVILEGE,
                    GRANTABLE,
                    GRANTOR
                FROM USER_TAB_PRIVS 
                WHERE OWNER = 'BENTIVI'
                ORDER BY TABLE_NAME, PRIVILEGE
            """,
            'description': 'Privil√©gios em objetos do schema BENTIVI'
        }
    }
    
    print("\n" + "="*60)
    print("üîê PRIVIL√âGIOS NO SCHEMA BENTIVI")
    print("="*60)
    
    results = {}
    for category, info in queries.items():
        df = execute_query_to_dataframe(engine, info['query'], info['description'])
        results[category] = df
    
    return results

# Fun√ß√£o removida - focando apenas no schema BENTIVI

def generate_summary(all_results: Dict[str, Dict[str, pd.DataFrame]]) -> Dict[str, Any]:
    """Gera resumo dos resultados"""
    summary = {
        'execution_time': datetime.now().isoformat(),
        'user': os.getenv('ORACLE_USER', 'GEODATA'),
        'database': f"{os.getenv('ORACLE_HOST')}:{os.getenv('ORACLE_PORT')}/{os.getenv('ORACLE_SERVICE_NAME')}",
        'categories': {}
    }
    
    for category_group, results in all_results.items():
        summary['categories'][category_group] = {}
        total_objects = 0
        
        for subcategory, df in results.items():
            count = len(df)
            summary['categories'][category_group][subcategory] = count
            total_objects += count
        
        summary['categories'][category_group]['total'] = total_objects
    
    return summary

def save_bentivi_report(all_results: Dict[str, Dict[str, pd.DataFrame]], summary: Dict[str, Any]):
    """Salva relat√≥rio focado no schema BENTIVI"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    report_file = f"bentivi_objects_report_{timestamp}.txt"
    
    with open(report_file, 'w', encoding='utf-8') as f:
        # Cabe√ßalho
        f.write("="*80 + "\n")
        f.write("RELAT√ìRIO DE OBJETOS DO SCHEMA BENTIVI\n")
        f.write("="*80 + "\n")
        f.write(f"Usu√°rio GEODATA - Acesso ao Schema: BENTIVI\n")
        f.write(f"Banco: {summary['database']}\n")
        f.write(f"Data/Hora: {summary['execution_time']}\n")
        f.write("="*80 + "\n\n")
        
        # Resumo geral
        f.write("üìä RESUMO GERAL - SCHEMA BENTIVI\n")
        f.write("-" * 50 + "\n")
        total_general = 0
        for category_group, cat_summary in summary['categories'].items():
            total_general += cat_summary['total']
            for subcategory, count in cat_summary.items():
                if subcategory != 'total' and count > 0:
                    f.write(f"‚Ä¢ {subcategory.replace('_', ' ').title()}: {count} objetos\n")
        
        f.write(f"\nüéØ TOTAL DE OBJETOS BENTIVI ACESS√çVEIS: {total_general}\n")
        f.write("\n" + "="*80 + "\n\n")
        
        # Detalhes por categoria
        for category_group, results in all_results.items():
            for subcategory, df in results.items():
                if not df.empty:
                    f.write(f"üìã {subcategory.replace('_', ' ').upper()} DO SCHEMA BENTIVI\n")
                    f.write("="*80 + "\n")
                    
                    # Listar todos os objetos - usando √≠ndices das colunas diretamente
                    for i, row in df.iterrows():
                        # Debug: mostrar todas as colunas dispon√≠veis
                        row_data = dict(row)
                        
                        # Tentar diferentes poss√≠veis nomes de coluna
                        object_name = None
                        for possible_col in ['TABLE_NAME', 'OBJECT_NAME', 'VIEW_NAME']:
                            if possible_col in row_data and pd.notna(row_data[possible_col]):
                                object_name = row_data[possible_col]
                                break
                        
                        if object_name is None:
                            # Se nenhuma coluna foi encontrada, usar a primeira coluna n√£o-nula
                            for col, val in row_data.items():
                                if pd.notna(val) and str(val).strip():
                                    object_name = val
                                    break
                        
                        object_name = object_name or 'NOME_NAO_IDENTIFICADO'
                        object_type = row_data.get('OBJECT_TYPE', 'TIPO_NAO_IDENTIFICADO')
                        
                        line = f"{i+1:4d}. BENTIVI.{object_name} ({object_type})"
                        
                        # Informa√ß√µes extras baseadas no que est√° dispon√≠vel
                        extra_info = []
                        
                        # Adicionar informa√ß√µes dispon√≠veis
                        for col, val in row_data.items():
                            if col in ['TABLE_NAME', 'OBJECT_TYPE', 'OBJECT_NAME', 'VIEW_NAME']:
                                continue  # J√° usamos essas
                                
                            if pd.notna(val) and str(val).strip():
                                val_str = str(val)
                                if col == 'NUM_ROWS' and val > 0:
                                    extra_info.append(f"Registros: {val:,}")
                                elif col == 'STATUS' and val_str.upper() != 'N/A':
                                    extra_info.append(f"Status: {val}")
                                elif col == 'TABLESPACE_NAME':
                                    extra_info.append(f"Tablespace: {val}")
                                elif col == 'TEXT_LENGTH':
                                    extra_info.append(f"Tamanho: {val} chars")
                                elif col == 'READ_ONLY':
                                    extra_info.append(f"Somente Leitura: {val}")
                                elif col in ['LAST_ANALYZED', 'CREATED', 'LAST_DDL_TIME']:
                                    extra_info.append(f"{col.replace('_', ' ').title()}: {str(val)[:10]}")
                                elif col == 'PRIVILEGE':
                                    extra_info.append(f"Privil√©gio: {val}")
                                elif col == 'GRANTABLE' and str(val).upper() == 'YES':
                                    extra_info.append("Pode conceder")
                        
                        if extra_info:
                            line += f"\n     [{', '.join(extra_info)}]"
                        
                        f.write(line + "\n")
                    
                    f.write(f"\n   TOTAL: {len(df)} {subcategory.replace('_', ' ')} encontradas\n")
                    f.write("\n" + "="*80 + "\n\n")
        
        # Se n√£o encontrou nenhum objeto
        if total_general == 0:
            f.write("‚ö†Ô∏è  ATEN√á√ÉO: Nenhum objeto encontrado no schema BENTIVI\n")
            f.write("   Poss√≠veis causas:\n")
            f.write("   ‚Ä¢ Schema BENTIVI n√£o existe\n")
            f.write("   ‚Ä¢ Usu√°rio GEODATA n√£o tem privil√©gios de acesso\n")
            f.write("   ‚Ä¢ Schema est√° vazio\n\n")
        
        # Rodap√©
        f.write("INFORMA√á√ïES ADICIONAIS\n")
        f.write("-" * 40 + "\n")
        f.write("‚Ä¢ Este relat√≥rio mostra APENAS objetos do schema BENTIVI\n")
        f.write("‚Ä¢ Tipos de objeto: TABELAS, VIEWS, PROCEDURES, FUNCTIONS\n")
        f.write("‚Ä¢ Usu√°rio consultado: GEODATA\n")
        f.write("‚Ä¢ Schema consultado: BENTIVI\n")
        f.write(f"‚Ä¢ Relat√≥rio gerado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write("\n" + "="*80 + "\n")
    
    print(f"üìã Relat√≥rio do schema BENTIVI salvo em: {report_file}")
    print(f"üìÑ Total de objetos encontrados: {total_general}")
    return report_file

def print_bentivi_summary(summary: Dict[str, Any]):
    """Exibe resumo focado no schema BENTIVI"""
    print("\n" + "="*80)
    print("üìä RESUMO - SCHEMA BENTIVI")
    print("="*80)
    print(f"üë§ Usu√°rio: GEODATA")
    print(f"üóÑÔ∏è  Schema: BENTIVI")
    print(f"üóÑÔ∏è  Banco: {summary['database']}")
    print(f"‚è∞ Data/Hora: {summary['execution_time']}")
    print()
    
    total_general = 0
    for category_group, cat_summary in summary['categories'].items():
        for subcategory, count in cat_summary.items():
            if subcategory != 'total' and count > 0:
                print(f"üìÅ {subcategory.replace('_', ' ').title()}: {count} objetos")
                total_general += count
    
    print()
    if total_general > 0:
        print(f"üéØ TOTAL DE OBJETOS BENTIVI ACESS√çVEIS: {total_general}")
    else:
        print("‚ö†Ô∏è  Nenhum objeto encontrado no schema BENTIVI")
        print("   Verifique se o schema existe e se h√° privil√©gios de acesso")

def main():
    """Fun√ß√£o principal - foco no schema BENTIVI"""
    print("üöÄ AN√ÅLISE DE OBJETOS DO SCHEMA BENTIVI")
    print("=" * 80)
    print(f"üë§ Usu√°rio: GEODATA")
    print(f"üóÑÔ∏è  Schema: BENTIVI") 
    print(f"‚è∞ Iniciado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Conectar ao Oracle
    engine = get_oracle_engine()
    if not engine:
        print("üí• Falha na conex√£o. Verifique as credenciais no arquivo .env")
        return
    
    try:
        # Coletar dados apenas do schema BENTIVI
        all_results = {}
        
        # Objetos do schema BENTIVI
        all_results['bentivi_objects'] = get_bentivi_objects(engine)
        
        # Privil√©gios espec√≠ficos no schema BENTIVI
        all_results['bentivi_privileges'] = get_bentivi_privileges(engine)
        
        # Gerar resumo
        summary = generate_summary(all_results)
        
        # Exibir resumo no console
        print_bentivi_summary(summary)
        
        # Salvar arquivo
        print("\n" + "="*80)
        print("üíæ SALVANDO RELAT√ìRIO DO SCHEMA BENTIVI")
        print("="*80)
        report_file = save_bentivi_report(all_results, summary)
        
        print(f"\nüéâ An√°lise do schema BENTIVI conclu√≠da!")
        
    except Exception as e:
        print(f"üí• Erro durante a execu√ß√£o: {e}")
        
    finally:
        # Fechar engine
        engine.dispose()
        print("üîê Conex√£o Oracle fechada")

if __name__ == "__main__":
    main()